---
title: "Summary Report: SIGNAL + ncovtools"
author: "`r Sys.info()['user']`"
date: "`r Sys.Date()`"
output: 
  html_document:
    filename: "`r params$outfile`"
params:
  config: ""
  outfile: "`r paste0(Sys.Date(),'_report.html')`"
---

```{css, echo=FALSE}
h2,h3,{
  text-align: left;
}
h1,h4 {
  text-align: center;
}
```

```{r packages, include=FALSE}
########################### STEP 1 LOAD PACKAGES ###########################
library(yaml) #Load profile configuration
library(here) #Access project root directory

r=getOption("repos")
r["CRAN"] = "http://cran.us.r-project.org"
options(repos = r)

# Check for config file and if not found exit
if (!file.exists(params$config)) {
  stop(paste("Error: The config file", params$config, "does not exist."))
}
yaml_file_path <- params$config
config <- yaml.load_file(yaml_file_path)

# ipak - Load packages
## This will print a message indicating which packages were loaded and will not print the list of packages multiple times (i.e not full list of packages once per package as seen with lapply)
## If any of the packages fail to load, an error will be generated by the library function. The following will check if all packages were loaded successfully and print a message for each package that is loaded successfully and will generate an error if any package could not be loaded. The stop function will halt the script and print the error message.

ipak <- function(pkg){
  # Checks what is needed to be installed so that it can be
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) {
    install.packages(new.pkg, dependencies = TRUE)
  }
  sapply(pkg, require, character.only = TRUE)
}

# Install with ipak and then check if everything is loadable
ipak(config$Packages)
packages_loaded <- sapply(config$Packages, function(pkg) {
  if(require(pkg, character.only = TRUE)) {
    message(paste0("Package '", pkg, "' was loaded successfully."))
    return(pkg)
  } else {
    stop(paste0("Package '", pkg, "' could not be loaded."))
  }
})


# - Step 2. Setup and find data -------------------------------
# Set the path to the data
data_folder <- config$Base_path

# Set folders to compare (avoiding absolute path here)
Name_of_folder_one <- config$Name_of_folder_one
Name_of_folder_two <- config$Name_of_folder_two

# Find the ncov-tools <RUN>_tree.nwk file in each folder individually
tree_f1_files <- list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_tree\\.nwk$", full.names = TRUE, recursive = TRUE)
if (length(tree_f1_files) == 0) {
  stop("*_tree.nwk file not found in folder ", file.path(data_folder, Name_of_folder_one))
}
tree_f1_dend <- tree_f1_files[1]

tree_f2_files <- list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_tree\\.nwk$", full.names = TRUE, recursive = TRUE)
if (length(tree_f2_files) == 0) {
  stop("*_tree.nwk file not found in folder ", file.path(data_folder, Name_of_folder_two))
}
tree_f2_dend <- tree_f2_files[1]


## Set the working directory ##
setwd(data_folder)

## Create lists for other report files (one per run so two in final list) ##
# Ambiguous position report <RUN>_ambiguous_position_report.tsv
ambiguous_position_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_ambiguous_position_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_ambiguous_position_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(ambiguous_position_report) != 2) {
  stop("Did not find a total of 2 ambiguous_position_report.tsv files in the input folders")
}

# Mixture report which is <RUN>_mixture_report.tsv
mixture_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_mixture_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_mixture_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(mixture_report) != 2) {
  stop("Did not find a total of 2 mixture_report.tsv files in the input folders")
}

# Ncov-Watch file which is <RUN>_ncov_watch_variants.tsv
ncov_watch_variants <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_ncov_watch_variants\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_ncov_watch_variants\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(ncov_watch_variants) != 2) {
  stop("Did not find a total of 2 ncov_watch_variants.tsv files in the input folders")
}

# Negative control report which is <RUN>_negative_control_report.tsv
negative_control_report <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_negative_control_report\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_negative_control_report\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(negative_control_report) != 2) {
  stop("Did not find a total of 2 negative_control_report.tsv files in the input folders")
}

# Summary report which is <RUN>_summary_qc.tsv
summary_qc <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*_summary_qc\\.tsv$", full.names = TRUE, recursive = TRUE), list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*_summary_qc\\.tsv$", full.names = TRUE, recursive = TRUE))
if (length(summary_qc) != 2) {
  stop("Did not find a total of 2 summary_qc.tsv files in the input folders")
}

# Specific NML report qc files
#  We're using the first one found as there are sample specific QC.CSV files located deeper down
#  This should use the summary ones first
signal_qc_csv <- c(list.files(file.path(data_folder, Name_of_folder_one), pattern = ".*\\.qc\\.csv$", full.names = TRUE, recursive = TRUE)[1], list.files(file.path(data_folder, Name_of_folder_two), pattern = ".*\\.qc\\.csv$", full.names = TRUE, recursive = TRUE)[1])
if (length(signal_qc_csv) != 2) {
  stop("Did not find a total of 2 *.qc.csv files in the input folders")
}


########################### Make a list of the lists above, excluding base_path and data_folder (to work with Kimia downstream) ########################### 
### Also want to remove the leading forward slash in the paths that populate list.of.files.1###
list.of.files.1 <- list(
  sub("^/", "", sub(data_folder, "", ambiguous_position_report)),
  sub("^/", "", sub(data_folder, "", mixture_report)),
  sub("^/", "", sub(data_folder, "", ncov_watch_variants)),
  sub("^/", "", sub(data_folder, "", negative_control_report)),
  sub("^/", "", sub(data_folder, "", summary_qc))
)

list.of.files_qc <- list(sub("^/", "", sub(data_folder, "", signal_qc_csv)))


# fread is much faster/convenient than read.table (detection is automatic);
# simplify=false --> rbindlist from data.table, the id column now contains the filenames

# There were some issues with the col types not matching, so setting them will prevent errors binding
# Make a function to select variables
setwd(data_folder)
for (i in seq_along(list.of.files.1)) {
  dt.list.1 <- sapply(list.of.files.1[[i]], fread, simplify=FALSE)
}

for (i in list.of.files.1) {
  require(list.of.files.1)
  dt.list.1[i] <- sapply(paste0(i), fread, simplify=FALSE)
}

# Make a function that converts column types
convert_column_types <- function(df_list, col_types) {
  # Apply the column types to each dataframe in the list
  df_list <- lapply(df_list, function(df) {
    # Convert the dataframe to a tibble to use the col_types
    df <- as_tibble(df)
    # Convert all columns to character first
    df <- df %>% mutate(across(everything(), as.character))
    # Apply the column types only to the columns that exist in the dataframe
    common_cols <- intersect(names(col_types$cols), names(df))
    df <- type_convert(df, col_types = cols(!!!col_types$cols[common_cols]))
    return(df)
  })
  
  return(df_list)
}

# Define the column types using column names
col_types <- cols(
  sample = col_character(),
  run_name = col_character(),
  run_identifier = col_logical(),
  num_consensus_snvs = col_integer(),
  num_consensus_n = col_integer(),
  num_consensus_iupac = col_integer(),
  num_variants_snvs = col_integer(),
  num_variants_indel = col_integer(),
  num_variants_indel_triplet = col_integer(),
  mean_sequencing_depth = col_number(),
  qpcr_ct = col_logical(),
  collection_date = col_logical(),
  num_weeks = col_logical(),
  scaled_variants_snvs = col_logical(),
  genome_completeness = col_number(),
  qc_pass = col_character(),
  lineage = col_character(),
  lineage_notes = col_character(),
  scorpio_call = col_character(),
  watch_mutations = col_character(),
  position = col_integer(),
  count = col_logical(),
  alleles = col_logical(),
  sample_a = col_logical(),
  sample_b = col_logical(),
  variants_checked = col_logical(),
  variants_mixed = col_logical(),
  read_support_allele_a = col_logical(),
  read_support_allele_b = col_logical(),
  mixture_fraction = col_logical(),
  mixed_sites = col_logical(),
  mutation = col_character(),
  contig = col_character(),
  reference = col_character(),
  alt = col_character(),
  file = col_character(),
  qc = col_character(),
  genome_covered_bases = col_character(),
  genome_total_bases = col_character(),
  genome_covered_fraction = col_character(),
  amplicons_detected = col_logical(),
  barcode = col_logical(),
  project_id = col_logical(),
  num_aligned_reads = col_integer(),
  variants = col_character(),
  protein_variants = col_character(),
  sequence_received_date = col_integer(),
  sequencing_technology = col_character(),
  snpeff_frameshift_consequence = col_logical(),
  diagnostic_primer_mutations = col_character(),
  sequencing_primer_mutations = col_character(),
  scheme = col_character(),
  version = col_character(),
  pangolin_note = col_character(),
  script_name = col_character(),
  revision = col_character(),
  next_flow_qc_pass = col_character()
)

dt.list.1 <- convert_column_types(dt.list.1, col_types)

# Combine the data tables into a single data table
DT.1 <- rbindlist(dt.list.1, idcol = 'id', fill = TRUE)


## Identify number of columns to separate by / in id
ncols <- max(str_count(DT.1$id, "/")) + 1

## Produce new columns that are separated by /
DT2<- cbind(DT.1,str_split_fixed(DT.1$id,"/",ncols))

## Again for nmlqc
setwd(data_folder)
for (i in seq_along(list.of.files_qc)) {
  dt.list.2 <- sapply(list.of.files_qc[[i]], fread, simplify=FALSE)
}
for(i in list.of.files_qc) {
  dt.list.2[i] <- sapply(paste0(i), fread, simplify=FALSE)
}

dt.list.2 <- convert_column_types(dt.list.2, col_types)

DT.2 <- rbindlist(dt.list.2, idcol = 'id',fill = TRUE)


# Combine the data tables into a single data table
DT.2 <- rbindlist(dt.list.2, idcol = 'id', fill = TRUE)


## identify number of columns to separate by / in id
ncols.2 <- max(str_count(DT.2$id, "/")) + 1

##produce new columns that are separated by /
DT2.2<- cbind(DT.2,str_split_fixed(DT.2$id,"/",ncols.2))

```

## Specific Files for analysis {.tabset}

------------------------------------------------------------------------

This is a summary report comparing `r length(unique(DT2$V1))` Runs: `r unique(DT2$V1)`.

### Files

The following files under **ncovtools** will be compared in this report:

```{r folders, echo=FALSE}
###### Make table of files to that are read in
files <- as.data.frame(c(unique(DT2$V5),unique(DT2.2$V3))) 
files.as.table.format <- files %>% 
  rename(Files=1) %>%
  kable(row.names = TRUE) %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)

files.as.table.format
```

### Path description and levels for files

```{r directory structure,echo=FALSE, warning=FALSE,, fig.align='left'}
### Path description and levels for files
# To maintain the previous method with the Base_path and Data_path, we grab current working dir and parent
current <- getwd()
parent_directory <- dirname(current)
PATHS <- list.files(parent_directory,
                  recursive = TRUE,
                  include.dirs = TRUE)
mytree <- data.tree::as.Node(data.frame(pathString = PATHS))
mytree
```

## Summary {.tabset}

------------------------------------------------------------------------

### Summary table:

This table identifies matching and discrepant values between aggregated outputs based on sample identifiers on summary_qc file.

```{r summary_table, echo=FALSE, warning=FALSE}
DT3_1 <- DT2 %>% 
  filter(V1==Name_of_folder_one) 
colnames(DT3_1) <- paste("1",colnames(DT3_1),sep = "_")
DT3_1 <- DT3_1 %>% 
  rename(sample=`1_sample`) %>%
  filter(!is.na(sample))


DT3_2 <- DT2 %>%
  filter(V1==Name_of_folder_two)
colnames(DT3_2) <- paste("2",colnames(DT3_2),sep = "_")
DT3_2 <- DT3_2 %>% 
  rename(sample=`2_sample`) %>%
  filter(!is.na(sample))
  

DT3_full <- merge(DT3_1,DT3_2,by="sample",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT4 <- DT3_full %>% select(-`2_collection_date`,-`1_collection_date`)
DT4[is.na(DT4)] <- "N/A"

#"num_consensus_snvs"
DT4$`num_consensus_snvs` <- ifelse(
  DT4$`1_num_consensus_snvs`==DT4$`2_num_consensus_snvs`,
  "MATCH",
  "**FAILED**")

#"num_consensus_n"
DT4$`num_consensus_n` <- ifelse(
  DT4$`1_num_consensus_n`==DT4$`2_num_consensus_n`,
  "MATCH",
  "**FAILED**")

#"num_consensus_iupac"
DT4$`num_consensus_iupac` <- ifelse(
  DT4$`1_num_consensus_iupac`==DT4$`2_num_consensus_iupac`,
  "MATCH",
  "**FAILED**")

#"num_variants_snvs"
DT4$`num_variants_snvs` <- ifelse(
  DT4$`1_num_variants_snvs`==DT4$`2_num_variants_snvs`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel"
DT4$`num_variants_indel` <- ifelse(
  DT4$`1_num_variants_indel`==DT4$`2_num_variants_indel`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel"
DT4$`num_variants_indel` <- ifelse(
  DT4$`1_num_variants_indel`==DT4$`2_num_variants_indel`,
  "MATCH",
  "**FAILED**")

#"num_variants_indel_triplet"
DT4$`num_variants_indel_triplet` <- ifelse(
  DT4$`1_num_variants_indel_triplet`==DT4$`2_num_variants_indel_triplet`,
  "MATCH",
  "**FAILED**")

#"mean_sequencing_depth"
DT4$`mean_sequencing_depth` <- ifelse(
  DT4$`1_mean_sequencing_depth`==DT4$`2_mean_sequencing_depth`,
  "MATCH",
  "**FAILED**")

#"median_sequencing_depth"
DT4$`median_sequencing_depth` <- ifelse(
  DT4$`1_median_sequencing_depth`==DT4$`2_median_sequencing_depth`,
  "MATCH",
  "**FAILED**")

#"scaled_variants_snvs"
DT4$`scaled_variants_snvs` <- ifelse(
  DT4$`1_scaled_variants_snvs`==DT4$`2_scaled_variants_snvs`,
  "MATCH",
  "**FAILED**")

#"genome_completeness"
DT4$`genome_completeness` <- ifelse(
  DT4$`1_genome_completeness`==DT4$`2_genome_completeness`,
  "MATCH",
  "**FAILED**")

#"qc_pass"
DT4$`qc_pass` <- ifelse(
  DT4$`1_qc_pass`==DT4$`2_qc_pass`,
  "MATCH",
  "**FAILED**")

#"lineage"
DT4$`lineage` <- ifelse(
  DT4$`1_lineage`==DT4$`2_lineage`,
  "MATCH",
  "**FAILED**")

#"lineage_notes"
DT4$`lineage_notes` <- ifelse(
  DT4$`1_lineage_notes`==DT4$`2_lineage_notes`,
  "MATCH",
  "**FAILED**")

#"scorpio_call"
DT4$`scorpio_call` <- ifelse(
  DT4$`1_scorpio_call`==DT4$`2_scorpio_call`,
  "MATCH",
  "**FAILED**")

#"watch_mutations"
DT4$`watch_mutations` <- ifelse(
  DT4$`1_watch_mutations`==DT4$`2_watch_mutations`,
  "MATCH",
  "**FAILED**")
```

```{r table_1, echo=FALSE}
DT4_all<-DT4 %>%
    filter(grepl("qc", `1_V5`)) %>%
  select(sample,num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,
         num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,
         genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations)
DT4_all[DT4_all=="MATCH"] <- "TRUE"
DT4_all[DT4_all=="**FAILED**"] <- "FALSE"

DT4_all <- DT4_all %>% convert(lgl(num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations))
# identify the logical columns
boolCols <- sapply(DT4_all, is.logical)
# sum each row of the logical columns and
# compare to the total number of logical columns
DT4_all$all_data <- rowSums(DT4_all[,..boolCols]) == sum(boolCols)

DT4_all$all_data <- as.character(DT4_all$all_data)
DT4_all$all_data[DT4_all$all_data=="FALSE"] <- "**FAILED**"
DT4_all_plot <- DT4_all %>% 
  select(sample,all_data) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT4_all_plot
```

### Summary table_detail:

```{r table_1_indetail, echo=FALSE}
DT4_final <- DT4 %>% 
  filter(grepl("qc", `1_V5`)) %>%
  select(sample,num_consensus_snvs,num_consensus_n,num_consensus_iupac,num_variants_snvs,num_variants_indel,
         num_variants_indel_triplet,mean_sequencing_depth,median_sequencing_depth,scaled_variants_snvs,
         genome_completeness,qc_pass,lineage,lineage_notes,scorpio_call,watch_mutations) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT4_final
```

## Summary of controls:

```{r table_2, echo=FALSE}

DT5_1 <- DT2 %>% 
  filter(grepl("negative", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(id,file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected,V1,V2)
colnames(DT5_1) <- paste("1",colnames(DT5_1),sep = "_")
DT5_1 <- DT5_1 %>% 
  rename(file=`1_file`) 
DT5_2 <- DT2 %>% 
  filter(grepl("negative", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(id,file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected,V1,V2)
colnames(DT5_2) <- paste("2",colnames(DT5_2),sep = "_")
DT5_2 <- DT5_2 %>% 
  rename(file=`2_file`) 

DT5_full <- merge(DT5_1,DT5_2,by="file",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT6 <- DT5_full
DT6[is.na(DT6)] <- "N/A"

#"qc"
DT6$`qc` <- ifelse(
  DT6$`1_qc`==DT6$`2_qc`,
  "MATCH",
  "**FAILED**")
#"genome_covered_bases"
DT6$`genome_covered_bases` <- ifelse(
  DT6$`1_genome_covered_bases`==DT6$`2_genome_covered_bases`,
  "MATCH",
  "**FAILED**")
#"genome_total_bases"
DT6$`genome_total_bases` <- ifelse(
  DT6$`1_genome_total_bases`==DT6$`2_genome_total_bases`,
  "MATCH",
  "**FAILED**")
#"genome_covered_fraction"
DT6$`genome_covered_fraction` <- ifelse(
  DT6$`1_genome_covered_fraction`==DT6$`2_genome_covered_fraction`,
  "MATCH",
  "**FAILED**")
#"amplicons_detected"
DT6$`amplicons_detected` <- ifelse(
  DT6$`1_amplicons_detected`==DT6$`2_amplicons_detected`,
  "MATCH",
  "**FAILED**")

DT6_final <- DT6 %>%
  select(file,qc,genome_covered_bases,genome_total_bases,genome_covered_fraction,amplicons_detected) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT6_final

##use the extraoperator library to produce a table of True/false for the columns required to identify IF controls match
qc=DT6$`1_qc` %a==% DT6$`2_qc`
genome_covered_bases=DT6$`1_genome_covered_bases` %a==% DT6$`2_genome_covered_bases`
genome_total_bases=DT6$`1_genome_total_bases` %a==% DT6$`2_genome_total_bases`
amplicons_detected=DT6$`1_amplicons_detected` %a==% DT6$`2_amplicons_detected`
```

The negative controls in this analysis `r ifelse((('TRUE' %in% qc)==TRUE & ('TRUE' %in% genome_covered_bases)==TRUE & ('TRUE' %in% genome_total_bases)==TRUE & ('TRUE' %in% amplicons_detected)==TRUE),"pass qc","do NOT pass qc")`.

## Summary of watch variants:

```{r table_3, echo=FALSE}
DT7_1 <- DT2 %>%
  filter(grepl("variants", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(sample,mutation,contig,position,reference,alt,V1,V2)%>%
  mutate(nuc_mut=paste0(reference,position,alt))
DT7_1 <- aggregate(nuc_mut ~ sample, data = DT7_1, paste, collapse=",")
colnames(DT7_1) <- paste("1",colnames(DT7_1),sep = "_")
DT7_1 <- DT7_1 %>% 
  rename(sample=`1_sample`) 

DT7_2 <- DT2 %>% 
  filter(grepl("variants", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(sample,mutation,contig,position,reference,alt,V1,V2)%>%
  mutate(nuc_mut=paste0(reference,position,alt))
DT7_2 <- aggregate(nuc_mut ~ sample, data = DT7_2, paste, collapse=",")
colnames(DT7_2) <- paste("2",colnames(DT7_2),sep = "_")
DT7_2 <- DT7_2 %>% 
  rename(sample=`2_sample`) 

DT7_full <- merge(DT7_1,DT7_2,by="sample",all.x = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT8 <- DT7_full
#"amplicons_detected"
DT8$`nucleotide_mutations` <- ifelse(
  DT8$`1_nuc_mut`==DT8$`2_nuc_mut`,
  "MATCH",
  "**FAILED**")
DT8_final <- DT8 %>%
  select(sample,nucleotide_mutations) %>%
  rename(`samples identified with watch mutations`=sample,) %>%
  mutate(`samples identified with watch mutations` = (gsub("[.]variants[.]norm[.]vcf", "", `samples identified with watch mutations`))) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT8_final

```

## Summary of mixtures:

```{r table_4, echo=FALSE}
DT9_1 <- DT2 %>% 
  filter(grepl("mixture", `V5`)) %>%
  filter(V1==Name_of_folder_one) %>%
  select(sample_a,sample_b,variants_checked,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites,V1,V2)%>%
  mutate(sample_a_b=paste0(sample_a,"_",sample_b))
colnames(DT9_1) <- paste("1",colnames(DT9_1),sep = "_")
DT9_1 <- DT9_1 %>% 
  rename(sample_a_sample_b=`1_sample_a_b`) 

DT9_2 <- DT2 %>% 
  filter(grepl("mixture", `V5`)) %>%
  filter(V1==Name_of_folder_two) %>%
  select(sample_a,sample_b,variants_checked,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites,V1,V2)%>%
  mutate(sample_a_b=paste0(sample_a,"_",sample_b))
colnames(DT9_2) <- paste("2",colnames(DT9_2),sep = "_")
DT9_2 <- DT9_2 %>% 
  rename(sample_a_sample_b=`2_sample_a_b`) 

DT9_full <- merge(DT9_1,DT9_2,by="sample_a_sample_b",all = TRUE,allow.cartesian=TRUE)

## Matching datasets except those with blank sample column
DT10 <- DT9_full
#"amplicons_detected"
DT10$`variants_checked` <- ifelse(
  DT10$`1_variants_checked`==DT10$`2_variants_checked`,
  "MATCH",
  "**FAILED**")
DT10$`variants_mixed` <- ifelse(
  DT10$`1_variants_mixed`==DT10$`2_variants_mixed`,
  "MATCH",
  "**FAILED**")
DT10$`read_support_allele_a` <- ifelse(
  DT10$`1_read_support_allele_a`==DT10$`2_read_support_allele_a`,
  "MATCH",
  "**FAILED**")
DT10$`read_support_allele_b` <- ifelse(
  DT10$`1_read_support_allele_b`==DT10$`2_read_support_allele_b`,
  "MATCH",
  "**FAILED**")
DT10$`mixture_fraction` <- ifelse(
  DT10$`1_mixture_fraction`==DT10$`2_mixture_fraction`,
  "MATCH",
  "**FAILED**")
DT10$`mixed_sites` <- ifelse(
  DT10$`1_mixed_sites`==DT10$`2_mixed_sites`,
  "MATCH",
  "**FAILED**")

DT10_final <- DT10 %>%
  select(sample_a_sample_b,variants_mixed,read_support_allele_a,read_support_allele_b,mixture_fraction,mixed_sites) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT10_final
```

## Output: {.tabset}

------------------------------------------------------------------------

### Standard deviation for numerical columns (summary_qc):

```{r summary_qc, echo=FALSE, warning=FALSE,fig.dim=c(8, 4), fig.align='left', out.width="100%"}
#####example summary_qc.tsv
summary_qc_DF1 <- DT2 %>% filter(grepl("qc", `V5`))

# 1. Standard Deviation Plot of Numerical Variables
summary_qc_DF1_SD=summary_qc_DF1 %>% 
  group_by(sample) %>%
  summarize(num_consensus_snvs=sd(num_consensus_snvs),
            num_consensus_n=sd(num_consensus_n),
            num_consensus_iupac=sd(num_consensus_iupac),
            num_variants_snvs=sd(num_variants_snvs),
            num_variants_indel=sd(num_variants_indel),
            num_variants_indel_triplet=sd(num_variants_indel_triplet),
            mean_sequencing_depth=sd(mean_sequencing_depth),
            median_sequencing_depth=sd(median_sequencing_depth),
            scaled_variants_snvs=sd(scaled_variants_snvs),
            genome_completeness=sd(genome_completeness))

  #Data Wrangling and Heatplot
SD_heatmapplot <- summary_qc_DF1_SD %>% 
  gather(variable,value,-sample) %>%
  arrange(sample) %>%
  mutate(sample=factor(sample)) %>%
  ggplot(aes(variable, sample, fill= value)) + 
  geom_tile(color = "white" ) +
  geom_text(aes(label = value), color = "white", size = 2) +
  guides(fill = guide_colourbar(title = "Standard Deviation",
                                barheight = 0.5,
                                ticks = FALSE)) +
  labs(title="Plot of SD by sample",
       x ="summary_qc", y = "Sample") +
  theme_grey(base_size = 5)
SD_heatmapplot
```

### Heatmaps (summary_qc):

```{r heatmaps,echo=FALSE, warning=FALSE,fig.dim=c(20, 7), fig.align='left'}
    ##QC heatmap showing n=1
summary_qc_DF1_qcpass <- aggregate(summary_qc_DF1$qc_pass, 
                                     by = list(summary_qc_DF1$sample,summary_qc_DF1$qc_pass,summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_qcpass <- summary_qc_DF1_qcpass %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
qcheatmap <- ggplot(summary_qc_DF1_qcpass,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of QC by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
qcheatmap
    ##lineage heatmap showing n=1
summary_qc_DF1_lineage <- aggregate(summary_qc_DF1$lineage, 
                                     by = list(summary_qc_DF1$sample,summary_qc_DF1$lineage,summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_lineage <- summary_qc_DF1_lineage %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
lineageheatmap <- ggplot(summary_qc_DF1_lineage,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of lineage by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
lineageheatmap
    ##lineage notes heatmap showing n=1
summary_qc_DF1_lineagenotes <- aggregate(summary_qc_DF1$lineage_notes, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$lineage_notes,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_lineagenotes <- summary_qc_DF1_lineagenotes %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
lineagenotesheatmap <- ggplot(summary_qc_DF1_lineagenotes,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",,
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of lineage notes by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
lineagenotesheatmap
    ##scorpio showing n=1
summary_qc_DF1_scorpio <- aggregate(summary_qc_DF1$scorpio_call, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$scorpio_call,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_scorpio <- summary_qc_DF1_scorpio %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
scorpioheatmap <- ggplot(summary_qc_DF1_scorpio,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.06),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of scorpio calls by sample",
     x ="summary_qc", y = "Sample") +
    theme_grey(base_size = 15) #+ theme(aspect.ratio = 0.5)
scorpioheatmap
```

```{r heatmaps2,echo=FALSE, warning=FALSE,fig.dim=c(20, 13), fig.align='left'}

##watch mutations showing n=1
summary_qc_DF1_watchmut <- aggregate(summary_qc_DF1$watch_mutations, 
                                     by = list(summary_qc_DF1$sample,
                                               summary_qc_DF1$watch_mutations,
                                               summary_qc_DF1$V1), 
                                     FUN = length)
summary_qc_DF1_watchmut <- summary_qc_DF1_watchmut %>% rename(sample=Group.1,
                                                                variable=Group.2,
                                                                `Number of IDs matching variable`=x)
watchmutheatmap <- ggplot(summary_qc_DF1_watchmut,
          aes(x=variable, y=sample,group=Group.3, color=Group.3,shape=Group.3)) +
  geom_point(aes(color= Group.3),
             position = position_dodge(0.1),
             size=5,
             shape=15) +
  scale_color_manual(name="Test",
                     values = c("#E69F00","#56B4E9")) +
  labs(title="Plot of watch mutations by sample",
     x ="summary_qc", y = "Sample") +
  scale_x_discrete(guide = guide_axis(angle = 90))
watchmutheatmap

```

### VCF comparison (qc.csv):

```{r mutation_table,echo=FALSE, warning=FALSE,fig.dim=c(20, 13), fig.align='left'}
DT2.2.1 <- DT2.2 %>% 
  filter(V1==Name_of_folder_one) %>%
  select(sample,variants,V1,V2)
colnames(DT2.2.1) <- paste("1",colnames(DT2.2.1),sep = "_")
DT2.2.1 <- DT2.2.1 %>% 
  rename(sample=`1_sample`)

DT2.2.2 <- DT2.2 %>% 
  filter(V1==Name_of_folder_two) %>%
  select(sample,variants,V1,V2)
colnames(DT2.2.2) <- paste("2",colnames(DT2.2.2),sep = "_")
DT2.2.2 <- DT2.2.2 %>% 
  rename(sample=`2_sample`) 

DT2.2.full <- merge(DT2.2.1,DT2.2.2,by="sample",all.x = TRUE,allow.cartesian=TRUE)
DT2.2.full$`1_variant_split` <- (strsplit(DT2.2.full$`1_variants`,";"))
DT2.2.full$`2_variant_split` <- strsplit(DT2.2.full$`2_variants`,";")

`%notin%` <- Negate(`%in%`)
  for(i in 1:nrow(DT2.2.full)) {
    DT2.2.full$count_of_F1_variants_in_F2_variants[i] <- sum(unlist(DT2.2.full[[8]][i]) %in% unlist(DT2.2.full[[9]][i]),na.rm = TRUE)
    DT2.2.full$count_of_F1_variants_NOT_in_F2_variants[i] <- sum(unlist(DT2.2.full[[8]][i]) %notin% unlist(DT2.2.full[[9]][i]),na.rm = TRUE)
    DT2.2.full$totalF1[i] <- length(unlist((DT2.2.full[[8]][i])))
    DT2.2.full$count_of_F2_variants_in_F1_variants[i] <- sum(unlist(DT2.2.full[[9]][i]) %in% unlist(DT2.2.full[[8]][i]),na.rm = TRUE)
    DT2.2.full$count_of_F2_variants_NOT_in_F1_variants[i] <- sum(unlist(DT2.2.full[[9]][i]) %notin% unlist(DT2.2.full[[8]][i]),na.rm = TRUE)
    DT2.2.full$totalF2[i] <- length(unlist(DT2.2.full[[9]][i]))
    DT2.2.full$`% match`[i] <- ((DT2.2.full$count_of_F1_variants_in_F2_variants[i]/DT2.2.full$totalF1[i])*100)
    }
 
#length(unlist(df[[8]][i]))

DT10_final <- DT2.2.full %>%
  select(sample,totalF1,totalF2,`% match`) %>%
  rename(!!Name_of_folder_one:=totalF1,
         !!Name_of_folder_two:=totalF2) %>%
  kable() %>%
  kable_styling(position = "left",font_size = 9,full_width = FALSE)
DT10_final
```

### Phylogenetic comparison (qc_analysis):

```{r phylogenetic comparison,echo=FALSE, warning=FALSE,fig.dim=c(20, 7), fig.align='left'}
##as.dendrogram (tanglegram)
Tree_F1_dend <- read.dendrogram(tree_f1_dend)
Tree_F2_dend <- read.dendrogram(tree_f2_dend)
DL <- dendlist(Tree_F1_dend,Tree_F2_dend)

##compute alignment quality (lower value == good alignment quality)
DL2 <- DL %>% 
  untangle() %>% 
  tanglegram(sort=TRUE) %>%
  set("labels_colors") 

entangl <- entanglement(DL2)
```

Entanglement for the above comparison is `r entangl` indicating `r ifelse(entangl=="0", "a perfect match", "noticible differences between same tips")`.

**END**

